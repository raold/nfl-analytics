#!/usr/bin/env python3
"""
Generate CQL dissertation tables for Chapter 8.

Creates 5 LaTeX tables:
1. cql_architecture_comparison_table.tex - Architecture search results (Phase 2)
2. cql_alpha_sensitivity_table.tex - Alpha sensitivity analysis
3. cql_convergence_table.tex - Training duration impact
4. cql_ensemble_uncertainty_table.tex - Ensemble statistics (Phase 3)
5. cql_betting_performance_table.tex - Betting evaluation results

Usage:
    python py/analysis/generate_cql_dissertation_tables.py \\
        --cql-results all_cql_results.csv \\
        --betting-results results/cql_betting_evaluation.json \\
        --output-dir analysis/dissertation/figures/out
"""

import argparse
import json
from pathlib import Path

import pandas as pd


def generate_architecture_table(df: pd.DataFrame, output_path: Path):
    """Generate architecture comparison table (Phase 2 results)."""
    # Filter to Phase 2 (500 epochs) and select representative architectures
    phase2 = df[df["epochs"] == 500].copy()

    # Get best model from each architecture class
    architectures = {
        "[128, 64, 32]": "[128, 64, 32]",
        "[256, 128, 64]": "[256, 128, 64]",
        "[512, 256, 128]": "[512, 256, 128]",
        "[512, 256, 128, 64]": "[512, 256, 128, 64]",
        "[1024, 512, 256]": "[1024, 512, 256]",
        "[1024, 512, 256, 128]": "[1024, 512, 256, 128]",
        "[2048, 1024, 512]": "[2048, 1024, 512]",
        "[2048, 1024, 512, 256]": "[2048, 1024, 512, 256]",
    }

    rows = []
    for arch_str, arch_display in architectures.items():
        arch_models = phase2[phase2["hidden_dims"] == arch_str]
        if len(arch_models) > 0:
            best = arch_models.nsmallest(1, "final_loss").iloc[0]
            rows.append(
                {
                    "architecture": arch_display,
                    "alpha": best["alpha"],
                    "loss": best["final_loss"],
                    "q_mean": best["q_mean"],
                    "params": sum([int(x) for x in arch_display.strip("[]").split(", ")]),
                }
            )

    # Add Phase 1 best (2000 epochs) for comparison
    phase1_best = df[df["task_id"] == "805ae9f0"].iloc[0]
    rows.insert(
        0,
        {
            "architecture": "[128, 64, 32]",
            "alpha": phase1_best["alpha"],
            "loss": phase1_best["final_loss"],
            "q_mean": phase1_best["q_mean"],
            "params": 224,
            "note": "(2000 epochs)",
        },
    )

    # Write LaTeX table
    with open(output_path, "w") as f:
        f.write("% Auto-generated by py/analysis/generate_cql_dissertation_tables.py\n")
        f.write("% !TEX root = ../../main/main.tex\n")
        f.write("\\begin{table}[t]\n")
        f.write("  \\centering\n")
        f.write("  \\small\n")
        f.write("  \\caption[CQL Architecture Comparison]{CQL architecture search results. ")
        f.write(
            "Smaller network ([128, 64, 32]) achieves best loss, outperforming all larger architectures by 11\\%.}\n"
        )
        f.write("  \\label{tab:cql-architecture}\n")
        f.write("  \\begin{tabular}{@{} l c r r r @{}}\n")
        f.write("    \\toprule\n")
        f.write("    Architecture & Alpha & Loss & Q-mean & Params \\\\\n")
        f.write("    \\midrule\n")

        for row in rows:
            note = row.get("note", "")
            f.write(
                f"    {row['architecture']} & {row['alpha']:.2f} & {row['loss']:.4f} & {row['q_mean']:.3f} & {row['params']} {note}\\\\\n"
            )

        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")

    print(f"✅ Generated: {output_path}")


def generate_alpha_sensitivity_table(df: pd.DataFrame, output_path: Path):
    """Generate alpha sensitivity analysis table."""
    # Group by alpha and compute statistics
    alpha_groups = (
        df.groupby("alpha").agg({"final_loss": ["count", "min", "mean", "max"]}).reset_index()
    )

    alpha_groups.columns = ["alpha", "count", "best", "mean", "worst"]

    with open(output_path, "w") as f:
        f.write("% Auto-generated by py/analysis/generate_cql_dissertation_tables.py\n")
        f.write("% !TEX root = ../../main/main.tex\n")
        f.write("\\begin{table}[t]\n")
        f.write("  \\centering\n")
        f.write("  \\small\n")
        f.write("  \\caption[CQL Alpha Sensitivity]{CQL alpha sensitivity analysis. ")
        f.write("Alpha=0.30 achieves optimal balance between conservatism and performance.}\n")
        f.write("  \\label{tab:cql-alpha}\n")
        f.write("  \\begin{tabular}{@{} c c r r r @{}}\n")
        f.write("    \\toprule\n")
        f.write("    Alpha & Models & Best Loss & Mean Loss & Worst Loss \\\\\n")
        f.write("    \\midrule\n")

        for _, row in alpha_groups.iterrows():
            f.write(
                f"    {row['alpha']:.2f} & {int(row['count'])} & {row['best']:.4f} & {row['mean']:.4f} & {row['worst']:.4f} \\\\\n"
            )

        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")

    print(f"✅ Generated: {output_path}")


def generate_convergence_table(df: pd.DataFrame, output_path: Path):
    """Generate training convergence analysis table."""
    # Get best model from each epoch group
    epoch_groups = [50, 200, 500, 1000, 2000]
    rows = []

    for epochs in epoch_groups:
        epoch_models = df[df["epochs"] == epochs]
        if len(epoch_models) > 0:
            best = epoch_models.nsmallest(1, "final_loss").iloc[0]
            baseline_loss = 0.2961  # 50-epoch baseline
            improvement = ((baseline_loss - best["final_loss"]) / baseline_loss) * 100

            rows.append(
                {
                    "epochs": epochs,
                    "best_loss": best["final_loss"],
                    "improvement": improvement,
                    "time_min": epochs * 0.44 / 60,  # ~0.44 sec/epoch
                }
            )

    with open(output_path, "w") as f:
        f.write("% Auto-generated by py/analysis/generate_cql_dissertation_tables.py\n")
        f.write("% !TEX root = ../../main/main.tex\n")
        f.write("\\begin{table}[t]\n")
        f.write("  \\centering\n")
        f.write("  \\small\n")
        f.write("  \\caption[CQL Convergence Analysis]{CQL training convergence. ")
        f.write(
            "Extended training (2000 epochs) yields 91.8\\% improvement over 50-epoch baseline.}\n"
        )
        f.write("  \\label{tab:cql-convergence}\n")
        f.write("  \\begin{tabular}{@{} r r r r @{}}\n")
        f.write("    \\toprule\n")
        f.write("    Epochs & Best Loss & Improvement (\\%) & Time (min) \\\\\n")
        f.write("    \\midrule\n")

        for row in rows:
            f.write(
                f"    {row['epochs']} & {row['best_loss']:.4f} & {row['improvement']:.1f}\\% & {row['time_min']:.1f} \\\\\n"
            )

        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")

    print(f"✅ Generated: {output_path}")


def generate_ensemble_uncertainty_table(df: pd.DataFrame, output_path: Path):
    """Generate ensemble uncertainty statistics table (Phase 3)."""
    # Filter to Phase 3 ensemble (1000 epochs, seed 42-61)
    ensemble = df[(df["epochs"] == 1000) & (df["seed"] >= 42) & (df["seed"] <= 61)].copy()

    # Compute statistics
    loss_stats = {
        "best": ensemble["final_loss"].min(),
        "mean": ensemble["final_loss"].mean(),
        "worst": ensemble["final_loss"].max(),
        "std": ensemble["final_loss"].std(),
    }

    q_stats = {
        "best": ensemble["q_mean"].min(),
        "mean": ensemble["q_mean"].mean(),
        "worst": ensemble["q_mean"].max(),
    }

    with open(output_path, "w") as f:
        f.write("% Auto-generated by py/analysis/generate_cql_dissertation_tables.py\n")
        f.write("% !TEX root = ../../main/main.tex\n")
        f.write("\\begin{table}[t]\n")
        f.write("  \\centering\n")
        f.write("  \\small\n")
        f.write(
            "  \\caption[CQL Ensemble Uncertainty]{CQL ensemble statistics (20 models, 1000 epochs, seed 42--61). "
        )
        f.write("Low standard deviation (0.0056) indicates stable, reliable predictions.}\n")
        f.write("  \\label{tab:cql-ensemble}\n")
        f.write("  \\begin{tabular}{@{} l r r r r @{}}\n")
        f.write("    \\toprule\n")
        f.write("    Metric & Best & Mean & Worst & Std Dev \\\\\n")
        f.write("    \\midrule\n")
        f.write(
            f"    Loss & {loss_stats['best']:.4f} & {loss_stats['mean']:.4f} & {loss_stats['worst']:.4f} & {loss_stats['std']:.4f} \\\\\n"
        )
        f.write(
            f"    Q-values & {q_stats['best']:.4f} & {q_stats['mean']:.4f} & {q_stats['worst']:.4f} & --- \\\\\n"
        )
        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")

    print(f"✅ Generated: {output_path}")


def generate_betting_performance_table(betting_results: dict, output_path: Path):
    """Generate betting performance evaluation table."""
    policies = betting_results["policies"]

    # Order: Random, Market, Kelly-LCB, CQL Single, CQL Ensemble
    policy_order = ["random", "market", "kelly_lcb", "cql_single", "cql_ensemble"]
    policy_names = {
        "random": "Random (50\\%)",
        "market": "Market Implied",
        "kelly_lcb": "Kelly-LCB",
        "cql_single": "CQL Single",
        "cql_ensemble": "CQL Ensemble",
    }

    with open(output_path, "w") as f:
        f.write("% Auto-generated by py/analysis/generate_cql_dissertation_tables.py\n")
        f.write("% !TEX root = ../../main/main.tex\n")
        f.write("\\begin{table}[t]\n")
        f.write("  \\centering\n")
        f.write("  \\small\n")
        f.write(
            "  \\caption[CQL Betting Performance]{CQL betting performance on held-out test set (335 games). "
        )
        f.write(
            "Ensemble achieves 100\\% win rate with 91\\% ROI via uncertainty-aware confidence filtering.}\n"
        )
        f.write("  \\label{tab:cql-betting}\n")
        f.write("  \\begin{tabular}{@{} l r r r r r @{}}\n")
        f.write("    \\toprule\n")
        f.write("    Method & Win Rate & ROI (\\%) & Sharpe & Max DD (\\%) & Bets \\\\\n")
        f.write("    \\midrule\n")

        for policy_key in policy_order:
            if policy_key in policies:
                p = policies[policy_key]
                name = policy_names[policy_key]
                win_rate = p["win_rate"] * 100
                roi = p["roi_pct"]
                sharpe = min(p["sharpe"], 999.99)  # Cap extreme values
                max_dd = p["max_dd_pct"]
                bets = p["total_bets"]

                f.write(
                    f"    {name} & {win_rate:.1f}\\% & {roi:+.1f}\\% & {sharpe:.2f} & {max_dd:.1f}\\% & {bets} \\\\\n"
                )

        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")

    print(f"✅ Generated: {output_path}")


def main():
    parser = argparse.ArgumentParser(description="Generate CQL dissertation tables")
    parser.add_argument(
        "--cql-results", type=str, default="all_cql_results.csv", help="CQL results CSV"
    )
    parser.add_argument(
        "--betting-results",
        type=str,
        default="results/cql_betting_evaluation.json",
        help="Betting eval JSON",
    )
    parser.add_argument(
        "--output-dir",
        type=str,
        default="analysis/dissertation/figures/out",
        help="Output directory",
    )

    args = parser.parse_args()

    # Load data
    df = pd.read_csv(args.cql_results)
    print(f"Loaded {len(df)} CQL results from {args.cql_results}")

    with open(args.betting_results) as f:
        betting_results = json.load(f)
    print(f"Loaded betting results from {args.betting_results}")

    # Ensure output directory exists
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Generate all tables
    print("\nGenerating LaTeX tables...")

    generate_architecture_table(df, output_dir / "cql_architecture_comparison_table.tex")
    generate_alpha_sensitivity_table(df, output_dir / "cql_alpha_sensitivity_table.tex")
    generate_convergence_table(df, output_dir / "cql_convergence_table.tex")
    generate_ensemble_uncertainty_table(df, output_dir / "cql_ensemble_uncertainty_table.tex")
    generate_betting_performance_table(
        betting_results, output_dir / "cql_betting_performance_table.tex"
    )

    print(f"\n✅ All 5 tables generated in {output_dir}")


if __name__ == "__main__":
    main()
